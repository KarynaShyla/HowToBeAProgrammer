# Как исправить проблемы производительности
[//]: # (Version:1.0.0)
Большинство программных проектов может быть выполнено с относительно небольшими усилиями, от 10 до 100 раз быстрее, чем в момент их первого выпуска(релиза). Под натиском, во время выхода на рынок, (проект хороший и(или) эффективный, стоит выбор, которое работает просто и быстро, но менее эффективно, чем какое-то другое решение. Тем не менее, производительность является частью юзабилити, и зачастую в конечном итоге должны рассматриваться более тщательно.) Тем не менее, производительность является частью юзабилити, и зачастую, в конечном итоге должна быть рассмотрена более тщательно.

Ключ к повышению производительности очень сложной системы это анализ, который достаточно хорошо, находит *bottlenecks*(узкие места), или места, где большая часть ресурсов потребляется(загружена). Нет большого смысла в оптимизации функции, которая составляет только 1% времени вычислений. (Как правило, вы должны тщательно подумать, прежде чем делать что-либо, если вы думаете, что он собирается сделать систему или значительную его часть как минимум вдвое быстрее). Обычно существуюет способ сделать это. Рассмотрим проверку(тесты) и гарантии качества(Quality Assurance) того, что потребует изменений. (Каждое изменение приносит тест на нагрузку с него, так гораздо лучше иметь несколько больших изменений).

После того как вы сделали двукратное улучшение в чем-то, нужно, как минимум, переосмыслить и, возможно, повторить анализ. Анализ позволит обнаружить остальные самые затратные  узкие места(bottlenecks) в системе, такие наступления(атаки или усилия) могут еще в два раза ускорить систему.

Часто, узким местом в производительности будет например подсчет коров путем подсчета их ног и деления на четыре, вместо подсчета голов. (Например, я сделал ошибки, такие как не в состоянии обеспечить системы реляционных баз данных с помощью соответствующего индекса на столбце я смотрю много, что, вероятно, сделало его не менее 20 раз медленнее). Другие примеры включают использование ненужного ввода/вывода во внутренних циклах, не убранные выражения для отладки, которые уже не нужны, лишние выделения памяти, и, в частности, неумелое использование библиотек и других подсистем, которые часто слабо документированы с точки зрения эксплуатационных характеристик(характеристик производительности). Такой вид улучшений иногда называют *low-hanging fruit*(низко висящие плоды), что означает, что он может быть легко выбраны(сняты), чтобы обеспечить какую-то пользу.

Что вы делаете, когда вы начинаете бежать от *low-hanging fruit*(низко висящих плодов)? Хорошо, вы можете сделать дерево более высоким или срубить его. По этой аналогии Вы можете продолжать делать небольшие улучшения или Вам придется серьезно перепроектировать систему или подсистему. (Это отличная возможность использовать свои навыки в качестве хорошего программиста, не только в новом дизайне, но и в том, чтобы убедить вашего босса, что это хорошая идея.) Однако, прежде чем вы спорите насчет перепроектирования подсистемы, вы должны спросить себя, являтся ли или не ваше предложение будет делать это пять-десять раз лучше.{Здесь плохой перевод}

Далее [Как оптимизировать циклы](07-How-to-Optimize-Loops.md)
